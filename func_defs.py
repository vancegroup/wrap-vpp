#-----------------------------------------------------------------
# pycparser: func_defs.py
#
# Using pycparser for printing out all the functions defined in a
# C file.
#
# This is a simple example of traversing the AST generated by
# pycparser.
#
# Copyright (C) 2008-2009, Eli Bendersky
# License: LGPL
#-----------------------------------------------------------------
import sys

from pycparser import c_parser, c_ast, parse_file

def renameFunctionToMethod(funcname):
	name = funcname[4:]
#	name = name[0:1].lower() + name[1:]
	return name + "  " + name[0:1].lower() + name[1:]

# A simple visitor for FuncDef nodes that prints the names and
# locations of function definitions.
#

class ContextVisitor(c_ast.NodeVisitor):
	def __init__(self):
		pass

	def prep(self, node):
		self.isMember = self.isMemberFunc(node.decl.type)
		self.retType = None
		self.params = None
		self.name = node.decl.name
		self.methodName = renameFunctionToMethod(self.name)
		self.location = node.decl.coord

		#for arg in node.decl.type.args.children():
		#		print "   ", arg.type , arg.name
		self.args = node.decl.type.args.children

	def visit_TypeDecl(self, node):
		if node.declname == self.name:
			# Then this is the declaration of the return type.
			self.retType = node.type.names

	def visit_IdentifierType(self, node):
		print "Found a type identifier: ", node.names

	def explain(self):
		print '%s: %s returns %s, takes:' % (context.location, context.name, context.retType)
		if self.isMember:
			print "MEMBER!"
		return

	def generateWrapper(self):
		declaration = " ".join(self.retType) + " " + self.methodName + "("
		declaration = declaration + (", ".join([str(x.name) for x in self.args()])) + ") "
		body = "{ return "
		return declaration + body

	def isMemberFunc(self, func_decl):
		#print func_decl.args.children()[0].type.name
		#if func_decl.args.children()[0].name == "VirtContext":
			return True
		#else:
		#	return False

class FuncDefVisitor(c_ast.NodeVisitor):
	#def visit_FuncDecl(self, func_decl):
		#func_decl = node.decl.type
	#	func_decl.show()
#		print '%s at %s: takes:' % (node.decl.name, node.decl.coord)
	#	print self.isMemberFunc(func_decl)
	#	for arg in func_decl.args.children():
	#		print "   ", arg.type , arg.name

	def visit_FuncDef(self, node):
		func_decl = node.decl.type
		#node.show()
		#context = ContextVisitor(node.decl.name)
		#context.visit(func_decl)
		context = ContextVisitor()
		context.prep(node)
		context.visit(node)
		print context.generateWrapper()
		#print self.isMemberFunc(func_decl)
		#for arg in func_decl.args.children():
		#	print "   ", arg.type , arg.name

#        print node.decl.func_decl.param_decls
#node.show()
#        if node.decl.FuncDecl.ParamList.Decl.TypeDecl.IdentifierType == 'VirtContext':
#           print



def show_func_defs(filename):
    # Note that cpp is used. Provide a path to your own cpp or
    # make sure one exists in PATH.
    #
    ast = parse_file(filename, use_cpp=True, cpp_args=r'-Iutils/fake_libc_include')

    v = FuncDefVisitor()
    v.visit(ast)


if __name__ == "__main__":
    if len(sys.argv) > 1:
        filename  = sys.argv[1]
    else:
        filename = 'VirtuoseAPI.h'

    show_func_defs(filename)
